
/*

//? 所谓 dependent name:
难道是 指从一个模板参数类型中 导入的名字： 所以在此处并不知道这个 name是不是存在的 ？？

//x==========================================================================================================

其实这里面体现的是 
//? [产生式]~~~~~~~~~~"利用不同功能组件的拼装组合， 产生一个可用的系统”
//?		1. 把一种功能做成一种组件。同时把功能的不同行为 对应成 组件的多种具体实现。
					举例： Copier ――> ElementCopier,  EmptyCopier
//?      2. 通过DSL，使得 用几个参数就能指定一种拼装方案，并完成拼装。
					举例： LIST_GENERATOR<Person, cp, poly, with_counter, with_tracing>::RET

********************************************************************************
//X 类型 = 数据+ 行为

//? ~~~~~~~~~~~~~~"一个组件"（Component），本身就对应 “一个类型”。 
//X							此系统是有A组件拼装起来的， 则： 模板，有个类型参数 A
//? ~~~~~~~而模板类型参数 是“把类型本身作为一个实体进行传递”，所以它 非常适合用来 “组装”组件。
//X 而子类型多态：组件实际已经组装好了，就像电脑已经规定了要有IO,CPU一样，你定制一台电脑时，不过是指定了具体的类型而已。

比如：你想定制一个有Dog的Man
//?	Interface: 实际上是死的，不具备“组件”的取舍能力。只是能多态化组件的行为
	手工装配： Man<Dog>
	DSL配置化产生： Man<has_dog>   ――> 内部： if(has_dog), RET = Man<Dog>
		

//x==========================================================================================================
// 通过成员接口
class Man{
	IDog* dog;

	void test(){ dog.bark(); }
}

*************************************************
// 通过模板的类型参数
template<typename Dog>
class Man
{
	Dog* dog;
	void test(){ dog.bark(); }
}





//X 以往的做法：  利用 Composition(组合)： 即通过持有一个Interface,然后赋其不同的实现类型，来实现多态化的组件行为。

//? 模板参数，比“通过成员持有” 这种组装 更灵活强大！！！
//x Interface持有： 实际上已经限制了：1. 必须依赖此组件  2. 此组件已经指定了一种类型。
――――> ★ 通过Interface可以做到的，模板参数都可以做到。


//X――――――――――> ~~~~~~ 因为 模板 本就意味着 比普通类 更大的自由度。


















*/