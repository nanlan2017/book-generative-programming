
//X ***********************************************************************************************
/*MARK
//X WHILE的行为： 检测当前条件值，若为true,则对当前Env进行一次迭代；
//?								否则,结束当前迭代

// 类模板总是比函数模板有更强大的表达能力，所以都是用类模板 ???
//?    ~~~~~1 ~~~~ 似“函数”模板  （有 RET）
//?				――> 返回一个数据：
//?							1. 整型数 enum RET 
//?							2. 类型实例（实例对象）  using RET     
//?	   ~~~~~2 ~~~~ 似“对象” 模板  (1个模板实例相当于一个对象instance) 
//x 而条件值为true/false： 是根据Env里的状态值计算出来的。  所以“条件”表示为： Cond(Env)
//x 进行一次迭代也是更新一次Env，而且行为是固定的。         所以“进行迭代”表示为： Iter(Env)

//x IF<> 是选择类型的，用在计算using RET 里。而enum里的 RET值 应该是用 ?:
*/
//X ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//? struct+ template memebr:  就是OO化的。 
//?     你可以通过选择返回不同的struct，从而返回不同的template (――> 返回元函数)