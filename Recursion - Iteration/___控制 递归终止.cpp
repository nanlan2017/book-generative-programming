/*
//? ~~~~~~~~~~ 问题很简单啊： 就是 f(n)要依赖 f(n-1)，你怎么控制其终止？
解法1：  if(n=1) return 3;       
	// 当参数为1时，返回一个明确值： ――――――――> 模板参数特化嘛！！！
解法2：  不要写 call f(n-1),   
		而是：  
			stop( return 3 )
			每次递归体内： next_f = n=1? stop() : f(n-1)       ;    call next_f


//X--------------------------------------------------------------------------------------------
//? 方式一： 通过模板特化。
递归的都是函数在递归。
而模板特化：
//X     就是说:   当这个“函数”(模板)的 某个参数为 某个“值”（类型实例/整型）时， 此函数不再继续往下迭代。


参考： 
	Switch_v2.cpp 中的Switch(tag,Case)

//x 定义一个递归终止的函数参数
		Switch()里会递归调用 Switch(tag, NextCase)
	――> 当Case为 NilCase时，终止递归。

//? 方式二： 不用模板的偏特化

//x	定义一个 Stop() 函数：
		表示递归终止条件时 所要调用的函数 （有明确的结果值）
	――> 每次递归时，先判断一下使用的下一次递归是 用自身、还是这个Stop函数。
//X--------------------------------------------------------------------------------------------

/*
//?  递归，就是遍历List的过程。
//?  ~~~~ 之前的 都是递归终止 都是用的 特化的整型参数（当n=0时，f(n)的值为多少）

//? ~~~~ 而这里的做法是： 先构建这个特化的 对象――――>~~~~和f()参数得是同一性质
//x			在 Length()这个递归中， 这个特殊参数就是 End这个节点。
//X                         _____>(模板特化匹配：能自动匹配到类型――一个实例对象)

//x  这个 特化的if值，将 f (k) 可以直接得到结果


//x   只能用参数整体来特化，  否则是没法匹配的（比如孤零零的DEFAULT_VAL）   > 这个参数值/类型名 是显式 有名字的
//?  ~~~~~~~~~ ――――――――>  所以： 构建一个和递归函数的参数同性质的 终止参数（int/ 一个type(表示一个特殊Node：EndEnv/NilCase)）
*/
*/